/*
    Boost Software License - Version 1.0 - August 17th, 2003

    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:

    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
 */

// See https://github.com/Ail-nare/Range-Vector for library's documentation and updates

#ifndef RANGE_RANGE_HPP
#define RANGE_RANGE_HPP

#include <iterator>
#include <stdexcept>
#include <array>

#if __cplusplus < 201703L // if version < C++17
class [[maybe_unused]] _range_optional_CXX14 {
    ptrdiff_t _value=0;
    bool _has_value=false;

public:
    [[maybe_unused]] constexpr _range_optional_CXX14()=default;
    [[maybe_unused]] constexpr _range_optional_CXX14(ptrdiff_t value)
        : _value(value), _has_value(true)
    {};

    [[maybe_unused]] [[nodiscard]] constexpr bool has_value() const
    {
        return this->_has_value;
    }

    [[maybe_unused]] [[nodiscard]] constexpr ptrdiff_t value() const
    {
        return this->_value;
    }
};

template <typename container>
constexpr auto _range_size_CXX14(const container& c) -> decltype(c.size())
{
    return c.size();
}

template <typename T, size_t n>
constexpr size_t _range_size_CXX14(const T (&array)[n]) noexcept
{
    return n;
}

 #define RANGE_GET_SIZE(x) _range_size_CXX14(x)

#else // if version >= C++17

#include <optional>
#define RANGE_GET_SIZE(x) std::size(x)

#endif


template <typename container_type, typename std::enable_if<
    std::is_same<
        typename std::iterator_traits<decltype(std::begin(std::declval<container_type&>()))>::iterator_category,
        std::random_access_iterator_tag>::value,
    int
>::type=0>
class range {
public:
    typedef typename std::remove_reference<decltype(*std::begin(std::declval<container_type&>()))>::type value_type;
protected:
    typedef typename std::add_const<container_type>::type const_container_type;
    typedef typename std::remove_const<container_type>::type unconst_container_type;

    typedef typename std::conditional<std::is_array<container_type>::value, std::array<value_type, sizeof(container_type) / sizeof(value_type)>, unconst_container_type>::type conversion_type;

    typedef range<const_container_type> const_range;
    typedef range<unconst_container_type> unconst_range;

    typedef decltype(std::begin(std::declval<container_type&>())) iterator_type;

    typedef ptrdiff_t difference_type;

#if __cplusplus >= 201703L // if version >= C++17
    typedef std::optional<ptrdiff_t> opt_difference_type;
#else // else version < C++17
    typedef _range_optional_CXX14 opt_difference_type;
#endif

public:
    class iterator : public std::iterator<std::random_access_iterator_tag, value_type> {
        iterator_type _it;
        ptrdiff_t _step;

    public:
        [[maybe_unused]] constexpr iterator(iterator_type it, ptrdiff_t step)
            : _it(it), _step(step)
        {}

        [[maybe_unused]] constexpr iterator()=default;
        [[maybe_unused]] constexpr iterator(const iterator &)=default;
        [[maybe_unused]] constexpr iterator(iterator &&) noexcept=default;

        [[maybe_unused]] constexpr iterator& operator=(const iterator &)=default;
        [[maybe_unused]] constexpr iterator& operator=(iterator &&) noexcept=default;

        [[maybe_unused]] [[nodiscard]] constexpr inline auto operator*() -> decltype(*this->_it)
        {
            return *this->_it;
        }

        [[maybe_unused]] [[nodiscard]] constexpr inline auto operator*() const -> decltype(*this->_it)
        {
            return *this->_it;
        }

        [[maybe_unused]] [[nodiscard]] constexpr inline auto operator->() -> decltype(*this->_it)
        {
            return *this->_it;
        }

        [[maybe_unused]] [[nodiscard]] constexpr inline auto operator->() const -> decltype(*this->_it)
        {
            return *this->_it;
        }


        [[maybe_unused]] constexpr inline iterator& operator++()
        {
            this->_it += this->_step;
            return *this;
        }

        [[maybe_unused]] constexpr inline iterator& operator--()
        {
            this->_it -= this->_step;
            return *this;
        }

        [[maybe_unused]] constexpr inline iterator operator++(int)
        {
            iterator tmp = *this;
            this->_it += this->_step;
            return tmp;
        }

        [[maybe_unused]] constexpr inline iterator operator--(int)
        {
            iterator tmp = *this;
            this->_it -= this->_step;
            return tmp;
        }

        [[maybe_unused]] constexpr inline iterator& operator+=(ptrdiff_t n)
        {
            this->_it += (this->_step * n);
            return *this;
        }

        [[maybe_unused]] constexpr inline iterator& operator-=(ptrdiff_t n)
        {
            this->_it -= (this->_step * n);
            return *this;
        }


        [[maybe_unused]] [[nodiscard]] constexpr inline iterator operator+(ptrdiff_t n) const
        {
            iterator new_it = *this;

            new_it._it += new_it._step * n;
            return new_it;
        }

        [[maybe_unused]] [[nodiscard]] constexpr inline iterator operator-(ptrdiff_t n) const
        {
            iterator new_it = *this;

            new_it._it -= new_it._step * n;
            return new_it;
        }


        [[maybe_unused]] [[nodiscard]] constexpr inline ptrdiff_t operator-(const iterator &other) const
        {
            return ((this->_step < 0) ? std::distance(this->_it, other._it) : std::distance(other._it, this->_it)) / this->_step;
        }


        [[maybe_unused]] [[nodiscard]] constexpr inline auto operator[](ptrdiff_t n)
        {
            return *(*this + n);
        }

        [[maybe_unused]] [[nodiscard]] constexpr inline auto operator[](ptrdiff_t n) const
        {
            return *(*this + n);
        }


        [[maybe_unused]] [[nodiscard]] constexpr inline bool operator<(const iterator &other) const
        {
            return (_step > 0) ?  (this->_it < other._it) : (other._it < this->_it);
        }

        [[maybe_unused]] [[nodiscard]] constexpr inline bool operator>(const iterator &other) const
        {
            return other < *this;
        }

        [[maybe_unused]] [[nodiscard]] constexpr inline bool operator<=(const iterator &other) const
        {
            return (_step > 0) ?  (this->_it <= other._it) : (other._it <= this->_it);
        }

        [[maybe_unused]] [[nodiscard]] constexpr inline bool operator>=(const iterator &other) const
        {
            return other <= *this;
        }


        [[maybe_unused]] [[nodiscard]] constexpr inline bool operator==(const iterator &other) const
        {
            return this->_it == other._it;
        }

        [[maybe_unused]] [[nodiscard]] constexpr inline bool operator!=(const iterator &other) const
        {
            return this->_it != other._it;
        }


        [[maybe_unused]] [[nodiscard]] constexpr inline iterator reverse() const
        {
            return {this->_it - this->_step, -this->_step};
        }
    };

private:
    iterator_type _start;
    iterator_type _end;
    ptrdiff_t _step;


protected:
    constexpr range(iterator_type start, iterator_type end, ptrdiff_t step)
        : _start(start), _end(end), _step(step)
    {}

public:
    constexpr range(iterator_type start, iterator_type end)
        : _start(start), _end(end), _step(((end - start) < 0) ? -1 : 1)
    {}

private:

    template <typename not_char_container_type, typename std::enable_if<!std::is_same<typename std::decay<not_char_container_type>::type, const char *>::value, int>::type=0>
    static inline constexpr auto _char_array_re_adjust(not_char_container_type &container)
    { // this is the default cases
        return std::end(container);
    }

    template <typename char_container_type, typename std::enable_if<std::is_same<typename std::decay<char_container_type>::type, const char *>::value, int>::type=0>
    static inline constexpr auto _char_array_re_adjust(char_container_type &container)
    { // the container id of type char[N]
        return std::end(container) - 1;
    }

public:

    [[maybe_unused]] constexpr explicit range(container_type &container)
        : _start(std::begin(container)), _end(_char_array_re_adjust<container_type>(container)), _step(1)
    {}

    [[maybe_unused]] constexpr range(const unconst_range &other)
        : _start(other._start), _end(other._end), _step(other._step)
    {}

    [[maybe_unused]] constexpr range(const const_range &other)
        : _start(other._start), _end(other._end), _step(other._step)
    {}

    [[maybe_unused]] constexpr range(unconst_range &&other) noexcept
        : _start(std::move(other._start)), _end(std::move(other._end)), _step(other._step)
    {}

    [[maybe_unused]] constexpr range(const_range &&other) noexcept
        : _start(std::move(other._start)), _end(std::move(other._end)), _step(other._step)
    {}

    [[maybe_unused]] range& operator=(const unconst_range &other)
    {
        this->_start = iterator_type(other._start);
        this->_end = iterator_type(other._end);
        this->_step = other._step;
        return *this;
    }

    [[maybe_unused]] range& operator=(const const_range &other)
    {
        this->_start = iterator_type(other._start);
        this->_end = iterator_type(other._end);
        this->_step = other._step;
        return *this;
    }

    [[maybe_unused]] range& operator=(unconst_range &&other) noexcept
    {
        this->_start = iterator_type(std::move(other._start));
        this->_end = iterator_type(std::move(other._end));
        this->_step = other._step;
        return *this;
    }

    [[maybe_unused]] range& operator=(const_range &&other) noexcept
    {
        this->_start = other._start;
        this->_end = other._end;
        this->_step = other._step;
        return *this;
    }


private:
    template <typename Container>
    [[maybe_unused]]static inline auto _reserve(Container &container, size_t new_cap)
        -> decltype(container.reserve(new_cap))
    {
        return container.reserve(new_cap);
    }

    template <typename Container>
    [[maybe_unused]] static inline constexpr void _reserve(Container &, int)
    {}

    template <typename Container, typename T>
    [[maybe_unused]] static inline auto _push(Container &container, const T& value, size_t&, int)
        -> decltype(container.push_back(value))
    {
        return container.push_back(value);
    }

    template <typename Container, typename T>
    [[maybe_unused]] static inline auto _push(Container &container, T&& value, size_t&, int)
        -> decltype(container.push_back(std::forward<T>(value)))
    {
        return container.push_back(std::forward<T>(value));
    }

    template <typename Container, typename T>
    [[maybe_unused]] static inline void _push(Container &container, const T& value, size_t &idx, long)
    {
        container[idx++] = value;
    }

    template <typename Container, typename T>
    [[maybe_unused]] static inline void _push(Container &container, T&& value, size_t &idx, long)
    {
        container[idx++] = std::forward<T>(value);
    }

public:
    [[maybe_unused]] [[nodiscard]] explicit operator conversion_type() const
    {
        unconst_container_type new_container;

        range::_reserve(new_container, this->size());

        size_t idx = 0;
        for (const auto &value : *this)
            range::_push(new_container, value, idx, 0);

        return new_container;
    }

    template <typename container>
    [[maybe_unused]] [[nodiscard]] container to() const
    {
        typename std::remove_const<typename std::remove_reference<container>::type>::type new_container;

        range::_reserve(new_container, this->size());

        size_t idx = 0;
        for (const auto &value : *this)
            range::_push(new_container, value, idx, 0);

        return new_container;
    }

    template <typename container>
    [[maybe_unused]] void to(container &cont) const
    {
        range::_reserve(cont, RANGE_GET_SIZE(cont) + this->size());

        size_t idx = 0;
        for (const auto &value : *this)
            range::_push(cont, value, idx, 0);

    }

    template <typename container, typename lambda>
    [[maybe_unused]] [[nodiscard]] container to(lambda fn) const
    {
        typename std::remove_const<typename std::remove_reference<container>::type>::type new_container;

        range::_reserve(new_container, this->size());

        size_t idx = 0;
        for (const auto &value : *this)
            range::_push(new_container, fn(value), idx, 0);

        return new_container;
    }

    template <typename container, typename lambda>
    [[maybe_unused]] void to(container &cont, lambda fn) const
    {
        range::_reserve(cont, RANGE_GET_SIZE(cont) + this->size());

        size_t idx = 0;
        for (const auto &value : *this)
            range::_push(cont, fn(value), idx, 0);
    }

    template <typename container>
    [[maybe_unused]] [[nodiscard]] constexpr container constexpr_to() const
    {
        typename std::remove_const<container>::type new_container{};
        const ptrdiff_t size = this->size();

        for (ptrdiff_t i = 0; i < size; ++i)
            new_container[i] = this->operator[](i);

        return new_container;
    }

    template <typename container, typename lambda>
    [[maybe_unused]] [[nodiscard]] constexpr container constexpr_to(lambda fn) const
    {
        typename std::remove_const<container>::type new_container{};
        const ptrdiff_t size = this->size();

        for (ptrdiff_t i = 0; i < size; ++i)
            new_container[i] = fn(this->operator[](i));

        return new_container;
    }


protected:
    [[maybe_unused]] [[nodiscard]] constexpr inline ptrdiff_t diff() const
    {
        return ((this->_step < 0) ? std::distance(this->_start, this->_end) : std::distance(this->_end, this->_start)) / this->_step;
    }

public:
    [[maybe_unused]] [[nodiscard]] constexpr inline size_t size() const
    {
        const ptrdiff_t diff = this->diff();

        return (diff >= 0) ? diff : -diff;
    }

    [[maybe_unused]] [[nodiscard]] constexpr inline range reverse() const
    {
        return {this->_end - this->_step, this->_start - this->_step, -this->_step};
    }


    // Member
    [[maybe_unused]] [[nodiscard]] constexpr inline range::iterator begin()
    {
        return {this->_start, this->_step};
    }

    [[maybe_unused]] [[nodiscard]] constexpr inline range::iterator end()
    {
        return {this->_end, this->_step};
    }

    [[maybe_unused]] [[nodiscard]] constexpr inline typename const_range::iterator begin() const
    {
        return static_cast<const_range>(*this).begin();
    }

    [[maybe_unused]] [[nodiscard]] constexpr inline typename const_range::iterator end() const
    {
        return static_cast<const_range>(*this).end();
    }

    [[maybe_unused]] [[nodiscard]] constexpr inline typename const_range::iterator cbegin() const
    {
        return static_cast<const_range>(*this).begin();
    }

    [[maybe_unused]] [[nodiscard]] constexpr inline typename const_range::iterator cend() const
    {
        return static_cast<const_range>(*this).end();
    }

    [[maybe_unused]] [[nodiscard]] constexpr inline range::iterator rbegin()
    {
        return {this->_end - this->_step, - this->_step};
    }

    [[maybe_unused]] [[nodiscard]] constexpr inline range::iterator rend()
    {
        return {this->_start - this->_step, - this->_step};
    }

    [[maybe_unused]] [[nodiscard]] constexpr inline typename const_range::iterator rbegin() const
    {
        return static_cast<const_range>(*this).rbegin();
    }

    [[maybe_unused]] [[nodiscard]] constexpr inline typename const_range::iterator rend() const
    {
        return static_cast<const_range>(*this).rend();
    }


private:

    [[nodiscard]] static constexpr difference_type get_value_from_opt(const opt_difference_type &opt, ptrdiff_t limite, difference_type d, const char *error1, const char *error2)
    {
        if (opt.has_value()) {
            difference_type n_start = opt.value();

            if (n_start < 0) {
                if (n_start < -limite)
                    throw std::out_of_range(error1);
                return n_start + limite;
            }
            if (n_start > limite)
                throw std::out_of_range(error2);
            return n_start;
        }
        return d;
    }
public:

    // Operator ()
    [[maybe_unused]] [[nodiscard]] constexpr range operator()(difference_type start)
    {
        ptrdiff_t size = this->size();
        start = (start >= 0) ? start : start + size;

        if (start < 0)
            throw std::out_of_range("range::operator(start): start < -this->size()");

        if (start > size)
            throw std::out_of_range("range::operator(start): start was bigger than this->size()");

        return {/*.start=*/this->_start + (start * this->_step),
                /*.end=*/this->_end,
                /*.step=*/this->_step
        };
    }

    [[maybe_unused]] [[nodiscard]] constexpr const_range operator()(difference_type start) const
    {
        ptrdiff_t size = this->size();
        start = (start >= 0) ? start : start + size;

        if (start < 0)
            throw std::out_of_range("range::operator(start): start < -this->size()");

        if (start > size)
            throw std::out_of_range("range::operator(start): start was bigger than this->size()");

        return {/*.start=*/this->_start + (start * this->_step),
                /*.end=*/this->_end,
                /*.step=*/this->_step
        };
    }

    [[maybe_unused]] [[nodiscard]] constexpr range operator()(opt_difference_type start, opt_difference_type end)
    {
        const ptrdiff_t size = this->size();
        difference_type n_start = get_value_from_opt(start, size, 0,
            "range::operator(start, end): start was smaller than -this->size()",
            "range::operator(start, end): start was bigger than this->size()");

        difference_type n_end = get_value_from_opt(end, size, size,
            "range::operator(start, end): end was smaller than -this->size()",
            "range::operator(start, end): end was bigger than this->size()");

        return {/*.start=*/this->_start + (n_start * this->_step),
                /*.end=*/this->_end + ((size - n_end) * -this->_step),
                /*.step=*/(n_start < n_end) ? this->_step : -this->_step
        };
    }

    [[maybe_unused]] [[nodiscard]] constexpr const_range operator()(opt_difference_type start, opt_difference_type end) const
    {
        const ptrdiff_t size = this->size();
        difference_type n_start = get_value_from_opt(start, size, 0,
            "range::operator(start, end): start was smaller than -this->size()",
            "range::operator(start, end): start was bigger than this->size()");

        difference_type n_end = get_value_from_opt(end, size, size,
            "range::operator(start, end): end was smaller than -this->size()",
            "range::operator(start, end): end was bigger than this->size()");

        return {/*.start=*/this->_start + (n_start * this->_step),
                /*.end=*/this->_end + ((size - n_end) * -this->_step),
                /*.step=*/(n_start < n_end) ? this->_step : -this->_step
        };
    }

    [[maybe_unused]] [[nodiscard]] constexpr range operator()(opt_difference_type start, opt_difference_type end, difference_type step)
    {
        if (step == 0)
            throw std::overflow_error("range::operator(start, end, step): the step can't be 0");

        ptrdiff_t size = this->size();
        difference_type n_start = get_value_from_opt(start, size, (step > 0) ? 0 : size - 1,
            "range::operator(start, end, step): start was smaller than -this->size()",
            "range::operator(start, end, step): start was bigger than this->size()");

        difference_type n_end = get_value_from_opt(end, size, (step > 0) ? size : -1,
            "range::operator(start, end, step): end was smaller than -this->size()",
            "range::operator(start, end, step): end was bigger than this->size()");

        if (step > 0) {
            if (n_start > n_end)
                throw std::out_of_range("range::operator(start, end, step): step is positive but start bigger than end");
        } else if (n_start < n_end)
            throw std::out_of_range("range::operator(start, end, step): step is positive but start smaller than end");

        // if step is negative
        if (step < 0) {
            const ptrdiff_t n_step = -step;
            const ptrdiff_t diff = (n_step - ((n_start - n_end) % n_step)) % n_step;

            return {/*.start=*/this->_end + ((n_start - size) * this->_step),
                    /*.end=*/this->_start + ((n_end - diff) * this->_step),
                    /*.step=*/this->_step * step
            };
        }

        // if step is positive
        const ptrdiff_t diff = (step - ((n_end - n_start) % step)) % step;

        return {/*.start=*/this->_start + (n_start * this->_step),
                /*.end=*/this->_start + ((n_end + diff) * this->_step),
                /*.step=*/this->_step * step
        };

        /* this is a more linear sadly it can't be used for constexpr and may be slower
        ptrdiff_t n_step = std::abs(step);

        range range = (step < 0) ? this->operator()(n_end + 1, n_start + 1).reverse() : this->operator()(n_start, n_end);
        ptrdiff_t diff = (n_step - (std::abs(n_start - n_end) % n_step)) % n_step;

        std::advance(range._end, diff * range._step);
        range._step *= n_step;

        return range;
         */
    }

    [[maybe_unused]] [[nodiscard]] constexpr const_range operator()(opt_difference_type start, opt_difference_type end, difference_type step) const
    {
        if (step == 0)
            throw std::overflow_error("range::operator(start, end, step): the step can't be 0");

        ptrdiff_t size = this->size();
        difference_type n_start = get_value_from_opt(start, size, (step > 0) ? 0 : size - 1,
            "range::operator(start, end, step): start was smaller than -this->size()",
            "range::operator(start, end, step): start was bigger than this->size()");

        difference_type n_end = get_value_from_opt(end, size, (step > 0) ? size : -1,
            "range::operator(start, end, step): end was smaller than -this->size()",
            "range::operator(start, end, step): end was bigger than this->size()");

        if (step > 0) {
            if (n_start > n_end)
                throw std::out_of_range("range::operator(start, end, step): step is positive but start bigger than end");
        } else if (n_start < n_end)
            throw std::out_of_range("range::operator(start, end, step): step is positive but start smaller than end");

        // if step is negative
        if (step < 0) {
            const ptrdiff_t n_step = -step;
            const ptrdiff_t diff = (n_step - ((n_start - n_end) % n_step)) % n_step;

            return {/*.start=*/this->_end + ((n_start - size) * this->_step),
                    /*.end=*/this->_start + ((n_end - diff) * this->_step),
                    /*.step=*/this->_step * step
            };
        }

        // if step is positive
        const ptrdiff_t diff = (step - ((n_end - n_start) % step)) % step;

        return {/*.start=*/this->_start + (n_start * this->_step),
                /*.end=*/this->_start + ((n_end + diff) * this->_step),
                /*.step=*/this->_step * step
        };
    }


    // Operator []
    [[maybe_unused]] [[nodiscard]] constexpr inline value_type operator[](difference_type n)
    {
        return *(this->begin() + n);
    }

    [[maybe_unused]] [[nodiscard]] constexpr inline typename const_range::value_type operator[](difference_type n) const
    {
        return *(this->begin() + n);
    }

    friend unconst_range;
    friend const_range;
};

#undef RANGE_GET_SIZE

#endif //RANGE_RANGE_HPP
